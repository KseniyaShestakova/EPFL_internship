/*
Copyright (C) 2017-2019 OpenIO SAS, as part of OpenIO SDS

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library.
*/

#include "server_variables.h" /* AUTO-GENERATED by confgen.py */

gint32 oio_server_request_failure_threshold = OIO_ENBUG_SERVER_REQUEST_FAILURE_THRESHOLD;
gint64 meta_queue_max_delay = OIO_META_QUEUE_MAX_DELAY;
guint server_accept_batch_size = OIO_SERVER_BATCH_ACCEPT;
guint server_event_batch_size = OIO_SERVER_BATCH_EVENTS;
gint64 server_cnx_ttl_idle = OIO_SERVER_CNX_TIMEOUT_IDLE;
gint64 server_cnx_ttl_never = OIO_SERVER_CNX_TIMEOUT_NEVER;
gint64 server_cnx_ttl_persist = OIO_SERVER_CNX_TIMEOUT_PERSIST;
guint server_fd_max_passive = OIO_SERVER_FD_MAX_PASSIVE;
guint malloc_trim_size_ondemand = OIO_SERVER_MALLOC_TRIM_SIZE_ONDEMAND;
guint sqlx_periodic_malloctrim_size = OIO_SERVER_MALLOC_TRIM_SIZE_PERIODIC;
guint sqlx_periodic_decache_max_bases = OIO_SERVER_PERIODIC_DECACHE_MAX_BASES;
gint64 sqlx_periodic_decache_max_delay = OIO_SERVER_PERIODIC_DECACHE_MAX_DELAY;
guint sqlx_periodic_decache_period = OIO_SERVER_PERIODIC_DECACHE_PERIOD;
gint64 server_threadpool_max_idle = OIO_SERVER_POOL_MAX_IDLE;
gint server_threadpool_max_tcp = OIO_SERVER_POOL_MAX_TCP;
gint server_threadpool_max_udp = OIO_SERVER_POOL_MAX_UDP;
gint server_threadpool_max_unused = OIO_SERVER_POOL_MAX_UNUSED;
gint64 server_queue_max_delay = OIO_SERVER_QUEUE_MAX_DELAY;
gint64 server_queue_warn_delay = OIO_SERVER_QUEUE_WARN_DELAY;
gint64 sqlx_request_max_run_time = OIO_SERVER_REQUEST_MAX_RUN_TIME;
guint sqlx_periodic_malloctrim_period = OIO_SERVER_TASK_MALLOC_TRIM_PERIOD;
guint server_udp_queue_maxlen = OIO_SERVER_UDP_QUEUE_MAX;
gint64 server_udp_queue_ttl = OIO_SERVER_UDP_QUEUE_TTL;
gint64 sqliterepo_server_exit_ttl = OIO_SQLITEREPO_SERVICE_EXIT_TTL;
gint64 oio_sqlx_lb_refresh_period = OIO_SQLX_LB_REFRESH_PERIOD;
gboolean oio_udp_allowed = OIO_UDP_ALLOWED;

static void __attribute__ ((constructor))
_declare_gboolean_OIO__OIO_SDS_SERVER_SERVER_VARIABLES_H_ (void) {

	oio_var_register_gint32(
		&oio_server_request_failure_threshold, OIO_VARKIND_size, "enbug.server.request.failure.threshold",
		"In testing situations, sets the average ratio of requests failing for a fake reason (from the peer). This helps testing the retrial mechanisms.",
		OIO_ENBUG_SERVER_REQUEST_FAILURE_THRESHOLD, 0, 100);

	oio_var_register_gint64(
		&meta_queue_max_delay, OIO_VARKIND_time, "meta.queue.max_delay",
		"Anti-DDoS counter-mesure. In the current server, sets the maximum amount of time a queued TCP event may remain in the queue. If an event is polled and the thread sees the event stayed longer than that delay, A '503 Unavailabe' error is replied.",
		OIO_META_QUEUE_MAX_DELAY, 10 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_guint(
		&server_accept_batch_size, OIO_VARKIND_size, "server.batch.accept",
		"In the network core, when the server socket wakes the call to epoll_wait(), that value sets the number of subsequent calls to accept(). Setting it to a low value allows to quickly switch to other events (established connection) and can lead to a strvation on the new connections. Setting to a high value might spend too much time in accepting and ease denials of service (with established but idle cnx).",
		OIO_SERVER_BATCH_ACCEPT, 1, 4096);

	oio_var_register_guint(
		&server_event_batch_size, OIO_VARKIND_size, "server.batch.events",
		"In the network core of a server, how many events do you manage in each call to epoll_wait(). Set to a low value to quickly react on new connections, to an higher value to rather treat established connections. The value is bound to a stack-allocated buffer, keep it rather small.",
		OIO_SERVER_BATCH_EVENTS, 1, 4096);

	oio_var_register_gint64(
		&server_cnx_ttl_idle, OIO_VARKIND_time, "server.cnx.timeout.idle",
		"In the current server, sets the maximumu amount of time a connection may live without activity since the last activity (i.e. the last reply sent)",
		OIO_SERVER_CNX_TIMEOUT_IDLE, 0, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&server_cnx_ttl_never, OIO_VARKIND_time, "server.cnx.timeout.never",
		"In the current server, sets the maximum amount of time an established connection is allowed to live when it has no activity at all.",
		OIO_SERVER_CNX_TIMEOUT_NEVER, 0, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&server_cnx_ttl_persist, OIO_VARKIND_time, "server.cnx.timeout.persist",
		"In the current server, sets the maximum amount of time a connection is allowed to live, since its creation by the accept() call, wheter it presents activity or not.",
		OIO_SERVER_CNX_TIMEOUT_PERSIST, 0, 1 * G_TIME_SPAN_DAY);

	oio_var_register_guint(
		&server_fd_max_passive, OIO_VARKIND_size, "server.fd_max_passive",
		"Maximum number of simultaneous incoming connections. Set to 0 for an automatic detection (50% of available file descriptors).",
		OIO_SERVER_FD_MAX_PASSIVE, 0, 65536);

	oio_var_register_guint(
		&malloc_trim_size_ondemand, OIO_VARKIND_size, "server.malloc_trim_size.ondemand",
		"Sets how many bytes bytes are released when the LEAN request is received by the current 'meta' service.",
		OIO_SERVER_MALLOC_TRIM_SIZE_ONDEMAND, 0, 2147483648);

	oio_var_register_guint(
		&sqlx_periodic_malloctrim_size, OIO_VARKIND_size, "server.malloc_trim_size.periodic",
		"Sets how many bytes bytes are released when the LEAN request is received by the current 'meta' service.",
		OIO_SERVER_MALLOC_TRIM_SIZE_PERIODIC, 0, 2147483648);

	oio_var_register_guint(
		&sqlx_periodic_decache_max_bases, OIO_VARKIND_size, "server.periodic_decache.max_bases",
		"How many bases may be decached each time the background task performs its Dance of Death",
		OIO_SERVER_PERIODIC_DECACHE_MAX_BASES, 1, 4194304);

	oio_var_register_gint64(
		&sqlx_periodic_decache_max_delay, OIO_VARKIND_time, "server.periodic_decache.max_delay",
		"How long may the decache routine take",
		OIO_SERVER_PERIODIC_DECACHE_MAX_DELAY, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_MINUTE);

	oio_var_register_guint(
		&sqlx_periodic_decache_period, OIO_VARKIND_size, "server.periodic_decache.period",
		"In ticks / jiffies, with approx. 1 tick per second. 0 means never",
		OIO_SERVER_PERIODIC_DECACHE_PERIOD, 0, 1048576);

	oio_var_register_gint64(
		&server_threadpool_max_idle, OIO_VARKIND_time, "server.pool.max_idle",
		"In the current server, sets how long a thread can remain unused before considered as idle (and thus to be stopped)",
		OIO_SERVER_POOL_MAX_IDLE, 1, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint(
		&server_threadpool_max_tcp, OIO_VARKIND_size, "server.pool.max_tcp",
		"In the current server, sets the maximum number of threads for the pool responsible for the TCP connections (threading model is one thread per request being managed, and one request at once per TCP connection). Set to 0 for no limit.",
		OIO_SERVER_POOL_MAX_TCP, 0, 1073741824);

	oio_var_register_gint(
		&server_threadpool_max_udp, OIO_VARKIND_size, "server.pool.max_udp",
		"In the current server, sets the maximum number of threads for pool responsible for the UDP messages handling. UDP is only used for quick synchronisation messages during MASTER elections. Set ot 0 for no limit.",
		OIO_SERVER_POOL_MAX_UDP, 0, 1073741824);

	oio_var_register_gint(
		&server_threadpool_max_unused, OIO_VARKIND_size, "server.pool.max_unused",
		"In the current server, sets how many threads may remain unused. This value is, in the GLib, common to all the threadpools.",
		OIO_SERVER_POOL_MAX_UNUSED, 0, 1073741824);

	oio_var_register_gint64(
		&server_queue_max_delay, OIO_VARKIND_time, "server.queue.max_delay",
		"Anti-DDoS counter-mesure. In the current server, sets the maximum amount of time a queued TCP event may remain in the queue. If an event is polled and the thread sees the event stayed longer than that delay, the connection is immediately closed. Keep this value rather high because the connection closing doesn't involve a reply that will help the client to retry with an exponential back-off.",
		OIO_SERVER_QUEUE_MAX_DELAY, 10 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint64(
		&server_queue_warn_delay, OIO_VARKIND_time, "server.queue.warn_delay",
		"In the current server, set the time threshold after which a warning is sent when a file descriptor stays longer than that in the queue of the Thread Pool.",
		OIO_SERVER_QUEUE_WARN_DELAY, 10 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint64(
		&sqlx_request_max_run_time, OIO_VARKIND_time, "server.request.max_run_time",
		"How long a request might take to run on the server side. This value is used to compute a deadline for several waitings (DB cache, manager of elections, etc). Common to all sqliterepo-based services, it might be overriden.",
		OIO_SERVER_REQUEST_MAX_RUN_TIME, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_alias("server.request.max_run_time", "server.request.max_delay_start");
	oio_var_register_guint(
		&sqlx_periodic_malloctrim_period, OIO_VARKIND_size, "server.task.malloc_trim.period",
		"In jiffies, how often the periodic task that calls malloc_trim() is fired.",
		OIO_SERVER_TASK_MALLOC_TRIM_PERIOD, 0, 86400);

	oio_var_register_guint(
		&server_udp_queue_maxlen, OIO_VARKIND_size, "server.udp_queue.max",
		"In the current server, sets the maximum length of the queue for UDP messages. When that number has been reached and a new message arrives, the message will be dropped.",
		OIO_SERVER_UDP_QUEUE_MAX, 0, 2147483648);

	oio_var_register_gint64(
		&server_udp_queue_ttl, OIO_VARKIND_time, "server.udp_queue.ttl",
		"In the current server, sets the maximum amount of time a queued UDP frame may remain in the queue. When unqueued, if the message was queued for too long, it will be dropped. The purpose of such a mechanism is to avoid clogging the queue and the whole election/cache mechanisms with old messages, those messages having already been resent.",
		OIO_SERVER_UDP_QUEUE_TTL, 100 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&sqliterepo_server_exit_ttl, OIO_VARKIND_time, "sqliterepo.service.exit_ttl",
		".",
		OIO_SQLITEREPO_SERVICE_EXIT_TTL, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint64(
		&oio_sqlx_lb_refresh_period, OIO_VARKIND_epoch, "sqlx.lb.refresh_period",
		"In the current sqlx-based service, tells the period (in seconds) at which the service will refresh its load-balancing information.",
		OIO_SQLX_LB_REFRESH_PERIOD, 1, 60);

	oio_var_register_gboolean(
		&oio_udp_allowed, "udp_allowed",
		"Allow the sqlx client DB_USE RPC to be sent via UDP instead of the default TCP channel.",
		OIO_UDP_ALLOWED);
}
