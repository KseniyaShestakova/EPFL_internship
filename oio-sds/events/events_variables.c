/*
Copyright (C) 2017-2019 OpenIO SAS, as part of OpenIO SDS

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "events_variables.h" /* AUTO-GENERATED by confgen.py */

gint64 oio_events_beanstalkd_check_level_alert = OIO_EVENTS_BEANSTALKD_CHECK_LEVEL_ALERT;
gint64 oio_events_beanstalkd_check_level_deny = OIO_EVENTS_BEANSTALKD_CHECK_LEVEL_DENY;
gint64 oio_events_beanstalkd_check_period = OIO_EVENTS_BEANSTALKD_CHECK_PERIOD;
gint64 oio_events_beanstalkd_default_delay = OIO_EVENTS_BEANSTALKD_DELAY;
guint oio_events_beanstalkd_default_prio = OIO_EVENTS_BEANSTALKD_PRIO;
gint64 oio_events_beanstalkd_timeout = OIO_EVENTS_BEANSTALKD_TIMEOUT;
gint64 oio_events_beanstalkd_default_ttr = OIO_EVENTS_BEANSTALKD_TTR;
gint64 oio_events_common_buffer_delay = OIO_EVENTS_COMMON_PENDING_DELAY;
guint32 oio_events_common_max_pending = OIO_EVENTS_COMMON_PENDING_MAX;
guint oio_events_zmq_max_recv = OIO_EVENTS_ZMQ_MAX_RECV;
gchar oio_meta1_tube_references [64] = OIO_META1_TUBE_REFERENCES;
gchar oio_meta1_tube_services [64] = OIO_META1_TUBE_SERVICES;
gchar oio_meta2_tube_container_deleted [64] = OIO_META2_TUBE_CONTAINER_DELETED;
gchar oio_meta2_tube_container_new [64] = OIO_META2_TUBE_CONTAINER_NEW;
gchar oio_meta2_tube_container_state [64] = OIO_META2_TUBE_CONTAINER_STATE;
gchar oio_meta2_tube_container_updated [64] = OIO_META2_TUBE_CONTAINER_UPDATED;
gchar oio_meta2_tube_content_appended [64] = OIO_META2_TUBE_CONTENT_APPENDED;
gchar oio_meta2_tube_content_broken [64] = OIO_META2_TUBE_CONTENT_BROKEN;
gchar oio_meta2_tube_content_created [64] = OIO_META2_TUBE_CONTENT_CREATED;
gchar oio_meta2_tube_content_deleted [64] = OIO_META2_TUBE_CONTENT_DELETED;
gchar oio_meta2_tube_content_drained [64] = OIO_META2_TUBE_CONTENT_DRAINED;
gchar oio_meta2_tube_content_updated [64] = OIO_META2_TUBE_CONTENT_UPDATED;
gchar oio_meta2_tube_meta2_deleted [64] = OIO_META2_TUBE_META2_DELETED;
gchar oio_rawx_tube_chunk_created [64] = OIO_RAWX_TUBE_CHUNK_CREATED;
gchar oio_rawx_tube_chunk_deleted [64] = OIO_RAWX_TUBE_CHUNK_DELETED;

static void __attribute__ ((constructor))
_declare_gboolean_OIO__OIO_SDS_EVENTS_EVENTS_VARIABLES_H_ (void) {

	oio_var_register_gint64(
		&oio_events_beanstalkd_check_level_alert, OIO_VARKIND_size, "events.beanstalkd.check_level_alert",
		"Set a threshold for the number of items in the beanstalkd, so that the service will alert past that value. Set to 0 for no alert sent.",
		OIO_EVENTS_BEANSTALKD_CHECK_LEVEL_ALERT, 0, G_MAXINT64);

	oio_var_register_gint64(
		&oio_events_beanstalkd_check_level_deny, OIO_VARKIND_size, "events.beanstalkd.check_level_deny",
		"Set the maximum number of items in beanstalkd before considering it full",
		OIO_EVENTS_BEANSTALKD_CHECK_LEVEL_DENY, 0, G_MAXINT64);

	oio_var_register_gint64(
		&oio_events_beanstalkd_check_period, OIO_VARKIND_time, "events.beanstalkd.check_period",
		"Set the interval between each check of the beanstalkd availability. Set to 0 to never check.",
		OIO_EVENTS_BEANSTALKD_CHECK_PERIOD, 0, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&oio_events_beanstalkd_default_delay, OIO_VARKIND_epoch, "events.beanstalkd.delay",
		"Sets the delay on each notification sent to the BEANSTALK endpoint",
		OIO_EVENTS_BEANSTALKD_DELAY, 0, 86400);

	oio_var_register_guint(
		&oio_events_beanstalkd_default_prio, OIO_VARKIND_size, "events.beanstalkd.prio",
		"Sets the priority of each notification sent to the BEANSTALK endpoint",
		OIO_EVENTS_BEANSTALKD_PRIO, 0, 2147483648);

	oio_var_register_gint64(
		&oio_events_beanstalkd_timeout, OIO_VARKIND_time, "events.beanstalkd.timeout",
		"Set the interval between each check of the beanstalkd availability. Set to 0 to never check.",
		OIO_EVENTS_BEANSTALKD_TIMEOUT, 100 * G_TIME_SPAN_MILLISECOND, 90 * G_TIME_SPAN_SECOND);

	oio_var_register_gint64(
		&oio_events_beanstalkd_default_ttr, OIO_VARKIND_epoch, "events.beanstalkd.ttr",
		"Sets the TTR (time to run) allow on the treatment of the notificatio sent to the beanstalkd",
		OIO_EVENTS_BEANSTALKD_TTR, 0, 86400);

	oio_var_register_gint64(
		&oio_events_common_buffer_delay, OIO_VARKIND_time, "events.common.pending.delay",
		"Sets the buffering delay of the events emitted by the application",
		OIO_EVENTS_COMMON_PENDING_DELAY, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_guint32(
		&oio_events_common_max_pending, OIO_VARKIND_size, "events.common.pending.max",
		"Sets the maximum number of pending events, not received yet by the endpoint",
		OIO_EVENTS_COMMON_PENDING_MAX, 1, 1048576);

	oio_var_register_guint(
		&oio_events_zmq_max_recv, OIO_VARKIND_size, "events.zmq.max_recv",
		"Sets the maximum number of ACK managed by the ZMQ notification client",
		OIO_EVENTS_ZMQ_MAX_RECV, 1, 1073741824);

	oio_var_register_string(
		oio_meta1_tube_references, "meta1.tube.references",
		"TODO: to be documented",
		OIO_META1_TUBE_REFERENCES, 64);

	oio_var_register_string(
		oio_meta1_tube_services, "meta1.tube.services",
		"TODO: to be documented",
		OIO_META1_TUBE_SERVICES, 64);

	oio_var_register_string(
		oio_meta2_tube_container_deleted, "meta2.tube.container_deleted",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTAINER_DELETED, 64);

	oio_var_register_string(
		oio_meta2_tube_container_new, "meta2.tube.container_new",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTAINER_NEW, 64);

	oio_var_register_string(
		oio_meta2_tube_container_state, "meta2.tube.container_state",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTAINER_STATE, 64);

	oio_var_register_string(
		oio_meta2_tube_container_updated, "meta2.tube.container_updated",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTAINER_UPDATED, 64);

	oio_var_register_string(
		oio_meta2_tube_content_appended, "meta2.tube.content_appended",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTENT_APPENDED, 64);

	oio_var_register_string(
		oio_meta2_tube_content_broken, "meta2.tube.content_broken",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTENT_BROKEN, 64);

	oio_var_register_string(
		oio_meta2_tube_content_created, "meta2.tube.content_created",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTENT_CREATED, 64);

	oio_var_register_string(
		oio_meta2_tube_content_deleted, "meta2.tube.content_deleted",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTENT_DELETED, 64);

	oio_var_register_string(
		oio_meta2_tube_content_drained, "meta2.tube.content_drained",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTENT_DRAINED, 64);

	oio_var_register_string(
		oio_meta2_tube_content_updated, "meta2.tube.content_updated",
		"TODO: to be documented",
		OIO_META2_TUBE_CONTENT_UPDATED, 64);

	oio_var_register_string(
		oio_meta2_tube_meta2_deleted, "meta2.tube.meta2_deleted",
		"TODO: to be documented",
		OIO_META2_TUBE_META2_DELETED, 64);

	oio_var_register_string(
		oio_rawx_tube_chunk_created, "rawx.tube.chunk_created",
		"TODO: to be documented",
		OIO_RAWX_TUBE_CHUNK_CREATED, 64);

	oio_var_register_string(
		oio_rawx_tube_chunk_deleted, "rawx.tube.chunk_deleted",
		"TODO: to be documented",
		OIO_RAWX_TUBE_CHUNK_DELETED, 64);
}
