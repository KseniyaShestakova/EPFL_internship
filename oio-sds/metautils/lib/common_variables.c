/*
Copyright (C) 2017-2019 OpenIO SAS, as part of OpenIO SDS

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library.
*/

#include "common_variables.h" /* AUTO-GENERATED by confgen.py */

gboolean oio_client_down_avoid = OIO_CLIENT_DOWN_CACHE_AVOID;
gboolean oio_client_down_shorten = OIO_CLIENT_DOWN_CACHE_SHORTEN;
gboolean oio_client_cache_errors = OIO_CLIENT_ERRORS_CACHE_ENABLED;
guint64 oio_client_cache_errors_max = OIO_CLIENT_ERRORS_CACHE_MAX;
gint64 oio_client_cache_errors_period = OIO_CLIENT_ERRORS_CACHE_PERIOD;
gint64 main_log_level_reset_delay = OIO_COMMON_VERBOSITY_RESET_DELAY;
gint32 oio_client_fake_timeout_threshold = OIO_ENBUG_CLIENT_FAKE_TIMEOUT_THRESHOLD;
gdouble oio_client_timeout_connect = OIO_GRIDD_TIMEOUT_CONNECT_COMMON;
gdouble oio_client_timeout_single = OIO_GRIDD_TIMEOUT_SINGLE_COMMON;
gdouble oio_client_timeout_whole = OIO_GRIDD_TIMEOUT_WHOLE_COMMON;
gdouble oio_m0_client_timeout_common = OIO_META0_OUTGOING_TIMEOUT_COMMON_REQ;
gdouble oio_m1_client_timeout_common = OIO_META1_OUTGOING_TIMEOUT_COMMON_REQ;
gint64 oio_ns_chunk_size = OIO_NS_CHUNK_SIZE;
guint oio_ns_flat_bits = OIO_NS_FLAT_BITS;
gboolean oio_ns_master = OIO_NS_MASTER;
guint oio_ns_meta1_digits = OIO_NS_META1_DIGITS;
gchar oio_ns_service_update_policy [1024] = OIO_NS_SERVICE_UPDATE_POLICY;
gchar oio_ns_storage_policy [128] = OIO_NS_STORAGE_POLICY;
gboolean oio_ns_mode_worm = OIO_NS_WORM;
gboolean oio_log_outgoing = OIO_SERVER_LOG_OUTGOING;
gboolean server_perfdata_enabled = OIO_SERVER_PERFDATA_ENABLED;
gboolean oio_socket_fastopen = OIO_SOCKET_FASTOPEN_ENABLED;
guint oio_socket_gridd_rcvbuf = OIO_SOCKET_GRIDD_RCVBUF;
guint oio_socket_gridd_sndbuf = OIO_SOCKET_GRIDD_SNDBUF;
gint64 oio_socket_linger_delay = OIO_SOCKET_LINGER_DELAY;
gboolean oio_socket_linger_onoff = OIO_SOCKET_LINGER_ENABLED;
gboolean oio_socket_nodelay = OIO_SOCKET_NODELAY_ENABLED;
gboolean oio_socket_quickack = OIO_SOCKET_QUICKACK_ENABLED;
gboolean oio_volume_lock_lazy = OIO_VOLUME_LAZY_LOCK;

static void __attribute__ ((constructor))
_declare_gboolean_OIO__OIO_SDS_METAUTILS_LIB_COMMON_VARIABLES_H_ (void) {

	oio_var_register_gboolean(
		&oio_client_down_avoid, "client.down_cache.avoid",
		"Should an error be raised when the peer is marked down, instead of trying to contact the peer.",
		OIO_CLIENT_DOWN_CACHE_AVOID);

	oio_var_register_gboolean(
		&oio_client_down_shorten, "client.down_cache.shorten",
		"Should the connection timeout be dramatically shortened when talking to a peer that has been reported down. Set to false by default, this is evaluated after the avoidance of those peers.",
		OIO_CLIENT_DOWN_CACHE_SHORTEN);

	oio_var_register_gboolean(
		&oio_client_cache_errors, "client.errors_cache.enabled",
		"Should the client feed a cache with the network errors it encounters, and should those errors be used to prevent RPC to be performed toward 'too-faulty' peers.",
		OIO_CLIENT_ERRORS_CACHE_ENABLED);

	oio_var_register_guint64(
		&oio_client_cache_errors_max, OIO_VARKIND_size, "client.errors_cache.max",
		"Sets the number of faults (on the period given by client.errors_cache.period) beyond which a peer is considered as too faulty to try a new RPC.",
		OIO_CLIENT_ERRORS_CACHE_MAX, 1, 4294967296);

	oio_var_register_gint64(
		&oio_client_cache_errors_period, OIO_VARKIND_epoch, "client.errors_cache.period",
		"Sets the size of the time window used to count the number of network errors.",
		OIO_CLIENT_ERRORS_CACHE_PERIOD, 1, 3600);

	oio_var_register_gint64(
		&main_log_level_reset_delay, OIO_VARKIND_time, "common.verbosity.reset_delay",
		"Tells how long the verbosity remains higher before being reset to the default, after a SIGUSR1 has been received.",
		OIO_COMMON_VERBOSITY_RESET_DELAY, 1 * G_TIME_SPAN_SECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint32(
		&oio_client_fake_timeout_threshold, OIO_VARKIND_size, "enbug.client.fake_timeout.threshold",
		"Set the probability of fake timeout failures, in any client RPC to a 'meta' service",
		OIO_ENBUG_CLIENT_FAKE_TIMEOUT_THRESHOLD, 0, 100);

	oio_var_register_gdouble(
		&oio_client_timeout_connect, OIO_VARKIND_time, "gridd.timeout.connect.common",
		"Sets the connection timeout, involved in any RPC to a 'meta' service.",
		OIO_GRIDD_TIMEOUT_CONNECT_COMMON, 0.1, 30.0);

	oio_var_register_gdouble(
		&oio_client_timeout_single, OIO_VARKIND_time, "gridd.timeout.single.common",
		"Sets the default timeout for unitary (request/response) RPC, without considering the possible redirection.",
		OIO_GRIDD_TIMEOUT_SINGLE_COMMON, 0.01, 120.0);

	oio_var_register_gdouble(
		&oio_client_timeout_whole, OIO_VARKIND_time, "gridd.timeout.whole.common",
		"Sets the global timeout of a RPC to e 'meta' service, considering all the possible redirections.",
		OIO_GRIDD_TIMEOUT_WHOLE_COMMON, 0.1, 120.0);

	oio_var_register_gdouble(
		&oio_m0_client_timeout_common, OIO_VARKIND_time, "meta0.outgoing.timeout.common.req",
		"Sets the timeout to the set of (quick) RPC that query a meta0 service",
		OIO_META0_OUTGOING_TIMEOUT_COMMON_REQ, 0.01, 60.0);

	oio_var_register_gdouble(
		&oio_m1_client_timeout_common, OIO_VARKIND_time, "meta1.outgoing.timeout.common.req",
		"Sets the timeout to the set of (quick) RPC that query a meta1 service",
		OIO_META1_OUTGOING_TIMEOUT_COMMON_REQ, 0.01, 60.0);

	oio_var_register_gint64(
		&oio_ns_chunk_size, OIO_VARKIND_size, "ns.chunk_size",
		"Default chunk size for the given namespace.",
		OIO_NS_CHUNK_SIZE, 1, G_MAXINT64);

	oio_var_register_guint(
		&oio_ns_flat_bits, OIO_VARKIND_size, "ns.flat_bits",
		"Default number of bits with flat-NS computation.",
		OIO_NS_FLAT_BITS, 0, 64);

	oio_var_register_gboolean(
		&oio_ns_master, "ns.master",
		"TODO: to be documented",
		OIO_NS_MASTER);

	oio_var_register_guint(
		&oio_ns_meta1_digits, OIO_VARKIND_size, "ns.meta1_digits",
		"Default number of digits to agregate meta1 databases.",
		OIO_NS_META1_DIGITS, 0, 4);

	oio_var_register_alias("ns.meta1_digits", "meta1_digits");
	oio_var_register_string(
		oio_ns_service_update_policy, "ns.service_update_policy",
		"TODO: to be documented",
		OIO_NS_SERVICE_UPDATE_POLICY, 1024);

	oio_var_register_string(
		oio_ns_storage_policy, "ns.storage_policy",
		"TODO: to be documented",
		OIO_NS_STORAGE_POLICY, 128);

	oio_var_register_gboolean(
		&oio_ns_mode_worm, "ns.worm",
		"Is the NS in a WORM (for Write Once, Read Many --but never delete).",
		OIO_NS_WORM);

	oio_var_register_gboolean(
		&oio_log_outgoing, "server.log_outgoing",
		"TODO: to be documented",
		OIO_SERVER_LOG_OUTGOING);

	oio_var_register_gboolean(
		&server_perfdata_enabled, "server.perfdata.enabled",
		"Enable server-side performance data collection.",
		OIO_SERVER_PERFDATA_ENABLED);

	oio_var_register_gboolean(
		&oio_socket_fastopen, "socket.fastopen.enabled",
		"Should the socket to meta~ services use TCP_FASTOPEN flag.",
		OIO_SOCKET_FASTOPEN_ENABLED);

	oio_var_register_guint(
		&oio_socket_gridd_rcvbuf, OIO_VARKIND_size, "socket.gridd.rcvbuf",
		"Set to a non-zero value to explicitely force a RCVBUF option on client sockets to gridd services. Set to 0 to keep the OS default.",
		OIO_SOCKET_GRIDD_RCVBUF, 0, 16777216);

	oio_var_register_guint(
		&oio_socket_gridd_sndbuf, OIO_VARKIND_size, "socket.gridd.sndbuf",
		"Set to a non-zero value to explicitely force a SNDBUF option on client sockets to gridd services. Set to 0 to keep the OS default.",
		OIO_SOCKET_GRIDD_SNDBUF, 0, 16777216);

	oio_var_register_gint64(
		&oio_socket_linger_delay, OIO_VARKIND_epoch, "socket.linger.delay",
		"When socket.linger.enabled is set to TRUE, socket.linger.delat tells how the socket remains in the TIME_WAIT state after the close() has been called.",
		OIO_SOCKET_LINGER_DELAY, 0, 60);

	oio_var_register_gboolean(
		&oio_socket_linger_onoff, "socket.linger.enabled",
		"Set to TRUE to allow the LINGER behavior of TCP sockets, as a default. The connections then end with a normal FIN packet, and go in the TIME_WAIT state for a given delay. Setting to FALSE causes connections to be closed with a RST packet, then avoiding a lot of TCP sockets in the TIME_WAIT state.",
		OIO_SOCKET_LINGER_ENABLED);

	oio_var_register_gboolean(
		&oio_socket_nodelay, "socket.nodelay.enabled",
		"Should the socket to meta~ services receive the TCP_NODELAY flag. When TRUE, it disables the Naggle's algorithm.",
		OIO_SOCKET_NODELAY_ENABLED);

	oio_var_register_gboolean(
		&oio_socket_quickack, "socket.quickack.enabled",
		"Should the sockets opened by the application receive the TCP_QUICKACK flag.",
		OIO_SOCKET_QUICKACK_ENABLED);

	oio_var_register_gboolean(
		&oio_volume_lock_lazy, "volume.lazy_lock",
		"Allow the services to self-assign to the volume they find in their configuration. This was the default behaviour in pre 5.2 versions of oio-sds.",
		OIO_VOLUME_LAZY_LOCK);
}
