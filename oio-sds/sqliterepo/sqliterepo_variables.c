/*
Copyright (C) 2017-2019 OpenIO SAS, as part of OpenIO SDS

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library.
*/

#include "sqliterepo_variables.h" /* AUTO-GENERATED by confgen.py */

gchar sqliterepo_election_2master_db [256] = OIO_ENBUG_ELECTION_DOUBLE_MASTER_DB;
gint32 oio_sqlx_request_failure_threshold = OIO_ENBUG_SQLITEREPO_CLIENT_FAILURE_THRESHOLD;
gint64 oio_sqlx_timeout_check_period = OIO_ENBUG_SQLITEREPO_CLIENT_TIMEOUT_PERIOD;
gint32 oio_sync_failure_threshold_action = OIO_ENBUG_SQLITEREPO_SYNCHRO_FAILURE;
guint32 _cache_heat_threshold = OIO_SQLITEREPO_CACHE_HEAT_THRESHOLD;
gboolean _cache_alert_on_heavy_load = OIO_SQLITEREPO_CACHE_HEAVYLOAD_ALERT;
gboolean _cache_fail_on_heavy_load = OIO_SQLITEREPO_CACHE_HEAVYLOAD_FAIL;
guint oio_sqliterepo_cache_kbytes_per_db = OIO_SQLITEREPO_CACHE_KBYTES_PER_DB;
gint64 _cache_period_cond_wait = OIO_SQLITEREPO_CACHE_TIMEOUT_LOCK;
gint64 _cache_timeout_open = OIO_SQLITEREPO_CACHE_TIMEOUT_OPEN;
gint64 _cache_grace_delay_cool = OIO_SQLITEREPO_CACHE_TTL_COOL;
gint64 _cache_grace_delay_hot = OIO_SQLITEREPO_CACHE_TTL_HOT;
guint32 _cache_max_waiting = OIO_SQLITEREPO_CACHE_WAITING_MAX;
gint64 oio_sqlx_timeout_check_max = OIO_SQLITEREPO_CLIENT_TIMEOUT_ALERT_IF_LONGER;
gint64 sqliterepo_dump_chunk_size = OIO_SQLITEREPO_DUMP_CHUNK_SIZE;
gint64 sqliterepo_dump_max_size = OIO_SQLITEREPO_DUMP_MAX_SIZE;
gint sqliterepo_dumps_max = OIO_SQLITEREPO_DUMPS_MAX;
gint64 sqliterepo_dumps_timeout = OIO_SQLITEREPO_DUMPS_TIMEOUT;
gboolean sqliterepo_allow_master = OIO_SQLITEREPO_ELECTION_ALLOW_MASTER;
gint64 oio_election_delay_expire_MASTER = OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_MASTER;
gint64 oio_election_delay_expire_NONE = OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_NONE;
gint64 oio_election_delay_expire_pending = OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_PENDING;
gint64 oio_election_delay_expire_SLAVE = OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_SLAVE;
gint64 oio_election_delay_retry_FAILED = OIO_SQLITEREPO_ELECTION_DELAY_RETRY_FAILED;
gboolean sqliterepo_election_lazy_recover = OIO_SQLITEREPO_ELECTION_LAZY_RECOVER;
gint64 oio_election_lock_alert_delay = OIO_SQLITEREPO_ELECTION_LOCK_ALERT_DELAY;
gint64 oio_election_delay_nowait_pending = OIO_SQLITEREPO_ELECTION_NOWAIT_AFTER;
gboolean oio_election_enable_nowait_pending = OIO_SQLITEREPO_ELECTION_NOWAIT_ENABLE;
gint64 oio_election_delay_wait = OIO_SQLITEREPO_ELECTION_WAIT_DELAY;
gint64 oio_election_period_cond_wait = OIO_SQLITEREPO_ELECTION_WAIT_QUANTUM;
guint _page_size = OIO_SQLITEREPO_PAGE_SIZE;
guint sqliterepo_release_size = OIO_SQLITEREPO_RELEASE_SIZE;
gint64 sqliterepo_active_queue_ttl = OIO_SQLITEREPO_REPO_ACTIVE_QUEUE_TTL;
guint sqliterepo_fd_max_active = OIO_SQLITEREPO_REPO_FD_MAX_ACTIVE;
guint sqliterepo_fd_min_active = OIO_SQLITEREPO_REPO_FD_MIN_ACTIVE;
guint sqliterepo_getvers_attempts = OIO_SQLITEREPO_REPO_GETVERS_ATTEMPTS;
gint64 sqliterepo_getvers_delay = OIO_SQLITEREPO_REPO_GETVERS_DELAY;
guint sqliterepo_repo_max_bases_hard = OIO_SQLITEREPO_REPO_HARD_MAX;
guint sqliterepo_repo_max_bases_soft = OIO_SQLITEREPO_REPO_SOFT_MAX;
gint64 sqliterepo_max_rss = OIO_SQLITEREPO_RSS_MAX;
gboolean sqliterepo_udp_deferred = OIO_SQLITEREPO_UDP_DEFERRED;
guint sqliterepo_zk_mux_factor = OIO_SQLITEREPO_ZK_MUX_FACTOR;
guint disconnection_threshold = OIO_SQLITEREPO_ZK_RRD_THRESHOLD;
guint disconnection_rrd_window = OIO_SQLITEREPO_ZK_RRD_WINDOW;
gboolean sqliterepo_zk_shuffle = OIO_SQLITEREPO_ZK_SHUFFLE;
gint64 sqliterepo_zk_timeout = OIO_SQLITEREPO_ZK_TIMEOUT;

static void __attribute__ ((constructor))
_declare_gboolean_OIO__OIO_SDS_SQLITEREPO_SQLITEREPO_VARIABLES_H_ (void) {

	oio_var_register_string(
		sqliterepo_election_2master_db, "enbug.election.double_master.db",
		"CID of the base to force a double master condition on.",
		OIO_ENBUG_ELECTION_DOUBLE_MASTER_DB, 256);

	oio_var_register_gint32(
		&oio_sqlx_request_failure_threshold, OIO_VARKIND_size, "enbug.sqliterepo.client.failure.threshold",
		"In testing situations, sets the average ratio of requests failing for a fake reason (from the peer). This helps testing the retrial mechanisms.",
		OIO_ENBUG_SQLITEREPO_CLIENT_FAILURE_THRESHOLD, 0, 100);

	oio_var_register_gint64(
		&oio_sqlx_timeout_check_period, OIO_VARKIND_time, "enbug.sqliterepo.client.timeout.period",
		"In testing situations, sets the average ratio of requests failing for a fake reason (connection timeout). This helps testing the retrial mechanisms and the behavior under strong network split-brain.",
		OIO_ENBUG_SQLITEREPO_CLIENT_TIMEOUT_PERIOD, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint32(
		&oio_sync_failure_threshold_action, OIO_VARKIND_size, "enbug.sqliterepo.synchro.failure",
		"Fake Error rate on synchronism RPC (a.k.a. ZK) ",
		OIO_ENBUG_SQLITEREPO_SYNCHRO_FAILURE, 0, 100);

	oio_var_register_guint32(
		&_cache_heat_threshold, OIO_VARKIND_size, "sqliterepo.cache.heat_threshold",
		"Sets the heat value below which a databse is considered hot",
		OIO_SQLITEREPO_CACHE_HEAT_THRESHOLD, 1, 2147483648);

	oio_var_register_gboolean(
		&_cache_alert_on_heavy_load, "sqliterepo.cache.heavyload.alert",
		"Triggers an alert when a thread tries to wait for an overloaded database.",
		OIO_SQLITEREPO_CACHE_HEAVYLOAD_ALERT);

	oio_var_register_gboolean(
		&_cache_fail_on_heavy_load, "sqliterepo.cache.heavyload.fail",
		"Triggers an error when a thread waits for an overloaded database.",
		OIO_SQLITEREPO_CACHE_HEAVYLOAD_FAIL);

	oio_var_register_guint(
		&oio_sqliterepo_cache_kbytes_per_db, OIO_VARKIND_size, "sqliterepo.cache.kbytes_per_db",
		"Number of kibibytes (kiB) of cache per open DB.",
		OIO_SQLITEREPO_CACHE_KBYTES_PER_DB, 0, 1048576);

	oio_var_register_gint64(
		&_cache_period_cond_wait, OIO_VARKIND_time, "sqliterepo.cache.timeout.lock",
		"Sets how long we (unit)wait on the lock around the databases. Keep it small.",
		OIO_SQLITEREPO_CACHE_TIMEOUT_LOCK, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint64(
		&_cache_timeout_open, OIO_VARKIND_time, "sqliterepo.cache.timeout.open",
		"Sets how long a worker thread accepts for a DB to become available.",
		OIO_SQLITEREPO_CACHE_TIMEOUT_OPEN, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&_cache_grace_delay_cool, OIO_VARKIND_time, "sqliterepo.cache.ttl.cool",
		"Sets the period after the return to the IDLE/COLD state, during which the recycling is forbidden. 0 means the base won't be decached.",
		OIO_SQLITEREPO_CACHE_TTL_COOL, 0, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&_cache_grace_delay_hot, OIO_VARKIND_time, "sqliterepo.cache.ttl.hot",
		"Sets the period after the return to the IDLE/HOT state, during which the recycling is forbidden. 0 means the base won't be decached.",
		OIO_SQLITEREPO_CACHE_TTL_HOT, 0, 1 * G_TIME_SPAN_DAY);

	oio_var_register_guint32(
		&_cache_max_waiting, OIO_VARKIND_size, "sqliterepo.cache.waiting.max",
		"Sets how many threads can wait on a single database. All the additional waiters will be denied with any wait attempt.",
		OIO_SQLITEREPO_CACHE_WAITING_MAX, 0, 2147483648);

	oio_var_register_gint64(
		&oio_sqlx_timeout_check_max, OIO_VARKIND_time, "sqliterepo.client.timeout.alert_if_longer",
		"In the current sqliterepo repository, sets the maximum amount of time a periodical task may take, while checking for the timeouts on the outbound connections.",
		OIO_SQLITEREPO_CLIENT_TIMEOUT_ALERT_IF_LONGER, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint64(
		&sqliterepo_dump_chunk_size, OIO_VARKIND_size, "sqliterepo.dump.chunk_size",
		"Size of data chunks when copying a database using the chunked DB_PIPEFROM/DB_DUMP mechanism.",
		OIO_SQLITEREPO_DUMP_CHUNK_SIZE, 4096, 2146435072);

	oio_var_register_gint64(
		&sqliterepo_dump_max_size, OIO_VARKIND_size, "sqliterepo.dump.max_size",
		"Maximum size of a database dump. If a base is bigger than this size, it will be refused the synchronous DB_RESTORE mechanism, and will be ansynchronously restored with the DB_DUMP/DB_PIPEFROM mechanism.",
		OIO_SQLITEREPO_DUMP_MAX_SIZE, 0, 2146435072);

	oio_var_register_gint(
		&sqliterepo_dumps_max, OIO_VARKIND_size, "sqliterepo.dumps.max",
		"How many concurrent DB dumps may happen in a single process.",
		OIO_SQLITEREPO_DUMPS_MAX, 1, G_MAXINT);

	oio_var_register_gint64(
		&sqliterepo_dumps_timeout, OIO_VARKIND_time, "sqliterepo.dumps.timeout",
		"How long to wait for a concurrent DB dump to finish. Should be set accordingly with sqliterepo.outgoing.timeout.req.resync.",
		OIO_SQLITEREPO_DUMPS_TIMEOUT, 1 * G_TIME_SPAN_SECOND, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gboolean(
		&sqliterepo_allow_master, "sqliterepo.election.allow_master",
		"Allow the role of MASTER in any election.",
		OIO_SQLITEREPO_ELECTION_ALLOW_MASTER);

	oio_var_register_gint64(
		&oio_election_delay_expire_MASTER, OIO_VARKIND_time, "sqliterepo.election.delay.expire_master",
		"In the current sqliterepo repository, sets the amount of time after which a MASTER election will drop its status and return to the NONE status. This helps recycling established-but-unused elections, and save Zookeeper nodes. Keep this value greater than sqliterepo.election.delay.expire_slave to avoid rotating the master service.",
		OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_MASTER, 1 * G_TIME_SPAN_MILLISECOND, 7 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&oio_election_delay_expire_NONE, OIO_VARKIND_time, "sqliterepo.election.delay.expire_none",
		"In the current sqliterepo repository, sets the amount of time an election without status will be forgotten ",
		OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_NONE, 1 * G_TIME_SPAN_SECOND, 1 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&oio_election_delay_expire_pending, OIO_VARKIND_time, "sqliterepo.election.delay.expire_pending",
		"Sets the amount of time after which a pending election (without any status change) will be reset and return to the NONE status. This helps recovering after a ZooKeeper failure. Should be set between sqliterepo.zk.timeout and sqliterepo.election.wait.delay.",
		OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_PENDING, 1 * G_TIME_SPAN_SECOND, 7 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&oio_election_delay_expire_SLAVE, OIO_VARKIND_time, "sqliterepo.election.delay.expire_slave",
		"In the current sqliterepo repository, sets the amount of time after which a SLAVE election will drop its status and return to the NONE status. This helps recycling established-but-unused elections, and save Zookeeper nodes.",
		OIO_SQLITEREPO_ELECTION_DELAY_EXPIRE_SLAVE, 1 * G_TIME_SPAN_SECOND, 7 * G_TIME_SPAN_DAY);

	oio_var_register_gint64(
		&oio_election_delay_retry_FAILED, OIO_VARKIND_time, "sqliterepo.election.delay.retry_failed",
		"In the current sqliterepo repository, sets the amount of time after which a failed election leaves its FAILED status and returns to the NONE status.",
		OIO_SQLITEREPO_ELECTION_DELAY_RETRY_FAILED, 1 * G_TIME_SPAN_MILLISECOND, 7 * G_TIME_SPAN_DAY);

	oio_var_register_gboolean(
		&sqliterepo_election_lazy_recover, "sqliterepo.election.lazy_recover",
		"Should the election mecanism try to recreate missing DB?",
		OIO_SQLITEREPO_ELECTION_LAZY_RECOVER);

	oio_var_register_gint64(
		&oio_election_lock_alert_delay, OIO_VARKIND_time, "sqliterepo.election.lock_alert_delay",
		"Only effective when built in DEBUG mode. Dump the long critical sections around the elections lock, when the lock is held for longer than this threshold (in microseconds).",
		OIO_SQLITEREPO_ELECTION_LOCK_ALERT_DELAY, 1, 60 * G_TIME_SPAN_SECOND);

	oio_var_register_gint64(
		&oio_election_delay_nowait_pending, OIO_VARKIND_time, "sqliterepo.election.nowait.after",
		"In the current sqliterepo repository, sets the amount of time spent in an election resolution that will make a worker thread won't wait at all and consider that election is stalled.",
		OIO_SQLITEREPO_ELECTION_NOWAIT_AFTER, 1 * G_TIME_SPAN_MILLISECOND, G_MAXINT64);

	oio_var_register_gboolean(
		&oio_election_enable_nowait_pending, "sqliterepo.election.nowait.enable",
		"Check of the election is pending since too long. If it is, don't way for it.",
		OIO_SQLITEREPO_ELECTION_NOWAIT_ENABLE);

	oio_var_register_gint64(
		&oio_election_delay_wait, OIO_VARKIND_time, "sqliterepo.election.wait.delay",
		"In the current sqliterepo repository, sets the maximum amount of time a worker thread is allowed to wait for an election to get its final status.",
		OIO_SQLITEREPO_ELECTION_WAIT_DELAY, 100 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_gint64(
		&oio_election_period_cond_wait, OIO_VARKIND_time, "sqliterepo.election.wait.quantum",
		"In the current sqliterepo repository, while loop-waiting for a final election status to be reached, this value sets the unit amount of time of eacch unit wait on the lock. Keep this value rather small to avoid waiting for too long, but not too small to avoid dumping CPU cycles in active waiting.",
		OIO_SQLITEREPO_ELECTION_WAIT_QUANTUM, 100 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);

	oio_var_register_guint(
		&_page_size, OIO_VARKIND_size, "sqliterepo.page_size",
		"In the current sqliterepo repository, sets the page size of all the databases used. This value only has effects on databases created with that value.",
		OIO_SQLITEREPO_PAGE_SIZE, 512, 1048576);

	oio_var_register_guint(
		&sqliterepo_release_size, OIO_VARKIND_size, "sqliterepo.release_size",
		"Sets how many bytes bytes are released when the LEAN request is received by the current 'meta' service.",
		OIO_SQLITEREPO_RELEASE_SIZE, 1, 2147483648);

	oio_var_register_gint64(
		&sqliterepo_active_queue_ttl, OIO_VARKIND_time, "sqliterepo.repo.active_queue_ttl",
		"In the current server, sets the maximum amount of time a queued DB_USE, DB_GETVERS or DB_PIPEFROM request may remain in the queue. If the message was queued for too long before being sent, it will be dropped. The purpose of such a mechanism is to avoid clogging the queue and the whole election/cache mechanisms with old messages, those messages having already been resent.",
		OIO_SQLITEREPO_REPO_ACTIVE_QUEUE_TTL, 100 * G_TIME_SPAN_MILLISECOND, 60 * G_TIME_SPAN_SECOND);

	oio_var_register_guint(
		&sqliterepo_fd_max_active, OIO_VARKIND_size, "sqliterepo.repo.fd_max_active",
		"Maximum number of simultaneous outgoing connections. Set to 0 for an automatic detection (2% of available file descriptors).",
		OIO_SQLITEREPO_REPO_FD_MAX_ACTIVE, 0, 65536);

	oio_var_register_guint(
		&sqliterepo_fd_min_active, OIO_VARKIND_size, "sqliterepo.repo.fd_min_active",
		"Minimum number of simultaneous outgoing connections.",
		OIO_SQLITEREPO_REPO_FD_MIN_ACTIVE, 0, 65536);

	oio_var_register_guint(
		&sqliterepo_getvers_attempts, OIO_VARKIND_size, "sqliterepo.repo.getvers_attempts",
		"Sets how many versions exchanges are allowed during the journey in the election FSM.",
		OIO_SQLITEREPO_REPO_GETVERS_ATTEMPTS, 1, 64);

	oio_var_register_alias("sqliterepo.repo.getvers_attempts", "sqliterepo.repo.getvers_max_retries");
	oio_var_register_gint64(
		&sqliterepo_getvers_delay, OIO_VARKIND_time, "sqliterepo.repo.getvers_delay",
		".",
		OIO_SQLITEREPO_REPO_GETVERS_DELAY, 10 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_MINUTE);

	oio_var_register_alias("sqliterepo.repo.getvers_delay", "sqliterepo.repo.getvers_backoff");
	oio_var_register_guint(
		&sqliterepo_repo_max_bases_hard, OIO_VARKIND_size, "sqliterepo.repo.hard_max",
		"Sets how many databases can be kept simultaneously open (in use or idle) in the current service. If defined to 0, it is set to 48% of available file descriptors.",
		OIO_SQLITEREPO_REPO_HARD_MAX, 0, 131072);

	oio_var_register_guint(
		&sqliterepo_repo_max_bases_soft, OIO_VARKIND_size, "sqliterepo.repo.soft_max",
		"Sets how many databases can be in use at the same moment in the current service. If defined to 0, it is set to sqliterepo.repo.hard_max.",
		OIO_SQLITEREPO_REPO_SOFT_MAX, 0, 131072);

	oio_var_register_gint64(
		&sqliterepo_max_rss, OIO_VARKIND_size, "sqliterepo.rss.max",
		"Memory size ceiling we try to honor. The check is performed while closing databases. Set to 0 to autodetect the max RSS from the resource limits (see `man getrlimit` for more information). The autodetection considers the environment and is not aware of all the processes that could share that environment.",
		OIO_SQLITEREPO_RSS_MAX, 0, G_MAXINT64);

	oio_var_register_gboolean(
		&sqliterepo_udp_deferred, "sqliterepo.udp_deferred",
		"Should the sendto() of DB_USE be deferred to a thread-pool. Only effective when `oio_udp_allowed` is set. Set to 0 to keep the OS default.",
		OIO_SQLITEREPO_UDP_DEFERRED);

	oio_var_register_guint(
		&sqliterepo_zk_mux_factor, OIO_VARKIND_size, "sqliterepo.zk.mux_factor",
		"For testing purposes. The value simulates ZK sharding on different connection to the same cluster.",
		OIO_SQLITEREPO_ZK_MUX_FACTOR, 1, 64);

	oio_var_register_guint(
		&disconnection_threshold, OIO_VARKIND_size, "sqliterepo.zk.rrd.threshold",
		"Sets the maximum number of reconnections to the ZK that remains acceptable. Beyond that limit, we consider the current service has been disconnected, and that it loast all its nodes.",
		OIO_SQLITEREPO_ZK_RRD_THRESHOLD, 1, 2147483648);

	oio_var_register_guint(
		&disconnection_rrd_window, OIO_VARKIND_size, "sqliterepo.zk.rrd.window",
		"Sets the time window to remember the reconnection events, on a ZK connection.",
		OIO_SQLITEREPO_ZK_RRD_WINDOW, 1, 4095);

	oio_var_register_gboolean(
		&sqliterepo_zk_shuffle, "sqliterepo.zk.shuffle",
		"Should the synchronism mechanism shuffle the set of URL in the ZK connection string? Set to yes as an attempt to a better balancing of the connections to the nodes of the ZK cluster.",
		OIO_SQLITEREPO_ZK_SHUFFLE);

	oio_var_register_gint64(
		&sqliterepo_zk_timeout, OIO_VARKIND_time, "sqliterepo.zk.timeout",
		"Sets the timeout of the zookeeper handle (in the meaning of the zookeeper client library)",
		OIO_SQLITEREPO_ZK_TIMEOUT, 1 * G_TIME_SPAN_MILLISECOND, 1 * G_TIME_SPAN_HOUR);
}
