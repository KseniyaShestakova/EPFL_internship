/*
Copyright (C) 2017-2017 OpenIO SAS, as part of OpenIO SDS

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/* !!!AUTOGENERATED!!! */
#include <metautils/lib/metautils.h>
#include <meta2v2/generic.h>
#include <meta2v2/autogen.h>
#include <glib.h>

const gchar *schema =
	"CREATE TABLE IF NOT EXISTS contents ("
	" id BLOB NOT NULL,"
	" hash BLOB,"
	" size INT NOT NULL,"
	" ctime INT NOT NULL,"
	" mtime INT NOT NULL,"
	" mime_type TEXT NOT NULL,"
	" chunk_method TEXT NOT NULL,"
	" policy TEXT,"
	" PRIMARY KEY (id)"
	");"
	"CREATE INDEX IF NOT EXISTS content_by_hash_size on contents(hash,size);"
	"CREATE TABLE IF NOT EXISTS chunks ("
	" id TEXT NOT NULL,"
	" content BLOB NOT NULL,"
	" position TEXT NOT NULL,"
	" hash BLOB NOT NULL,"
	" size INT NOT NULL,"
	" ctime INT NOT NULL,"
	" CONSTRAINT fk_CHUNKS_CONTENTS_HEADERS_2 FOREIGN KEY (content) REFERENCES contents(id) ON UPDATE CASCADE ON DELETE CASCADE,"
	" PRIMARY KEY (id)"
	");"
	"CREATE INDEX IF NOT EXISTS chunk_index_by_header on chunks(content);"
	"CREATE TABLE IF NOT EXISTS aliases ("
	" alias TEXT NOT NULL,"
	" version INT NOT NULL,"
	" content BLOB NOT NULL,"
	" deleted BOOL NOT NULL,"
	" ctime INT NOT NULL,"
	" mtime INT NOT NULL,"
	" CONSTRAINT fk_ALIASES_CONTENTS_HEADERS_1 FOREIGN KEY (content) REFERENCES contents(id) ON UPDATE CASCADE ON DELETE CASCADE,"
	" PRIMARY KEY (alias,version)"
	");"
	"CREATE INDEX IF NOT EXISTS alias_index_by_name on aliases(alias);"
	"CREATE INDEX IF NOT EXISTS alias_index_by_header on aliases(content);"
	"CREATE TABLE IF NOT EXISTS properties ("
	" alias TEXT NOT NULL,"
	" version INT NOT NULL,"
	" key TEXT NOT NULL,"
	" value BLOB NOT NULL,"
	" CONSTRAINT fk_PROPERTIES_ALIASES_0 FOREIGN KEY (alias,version) REFERENCES aliases(alias,version) ON UPDATE CASCADE ON DELETE CASCADE,"
	" PRIMARY KEY (alias,version,key)"
	");"
	"CREATE INDEX IF NOT EXISTS properties_index_by_header_version on properties(alias,version);"
	"INSERT OR IGNORE INTO admin(k,v) VALUES (\"schema_version\",\"1.8\");"
	"INSERT OR IGNORE INTO admin(k,v) VALUES (\"version:main.admin\",\"1:0\");"
	"INSERT OR IGNORE INTO admin(k,v) VALUES (\"version:main.contents\",\"1:0\");"
	"INSERT OR IGNORE INTO admin(k,v) VALUES (\"version:main.chunks\",\"1:0\");"
	"INSERT OR IGNORE INTO admin(k,v) VALUES (\"version:main.aliases\",\"1:0\");"
	"INSERT OR IGNORE INTO admin(k,v) VALUES (\"version:main.properties\",\"1:0\");"
;
static struct fk_field_s descr_fk_fields_in_FK_PROPERTIES_ALIASES_0[] =
{
	{0,"alias"}, {1,"version"}, {-1,NULL}
};

static struct fk_field_s descr_fk_fields_out_FK_PROPERTIES_ALIASES_0[] =
{
	{0,"alias"},{1,"version"}, {-1,NULL}
};

static struct fk_field_s descr_fk_fields_in_FK_ALIASES_CONTENTS_HEADERS_1[] =
{
	{2,"content"}, {-1,NULL}
};

static struct fk_field_s descr_fk_fields_out_FK_ALIASES_CONTENTS_HEADERS_1[] =
{
	{0,"id"}, {-1,NULL}
};

static struct fk_field_s descr_fk_fields_in_FK_CHUNKS_CONTENTS_HEADERS_2[] =
{
	{1,"content"}, {-1,NULL}
};

static struct fk_field_s descr_fk_fields_out_FK_CHUNKS_CONTENTS_HEADERS_2[] =
{
	{0,"id"}, {-1,NULL}
};

struct fields_CONTENTS_HEADERS_s {
	GByteArray * id;
	GByteArray * hash;
	gint64 size;
	gint64 ctime;
	gint64 mtime;
	GString * mime_type;
	GString * chunk_method;
	GString * policy;
};

struct fields_CHUNKS_s {
	GString * id;
	GByteArray * content;
	GString * position;
	GByteArray * hash;
	gint64 size;
	gint64 ctime;
};

struct fields_PROPERTIES_s {
	GString * alias;
	gint64 version;
	GString * key;
	GByteArray * value;
};

struct fields_ALIASES_s {
	GString * alias;
	gint64 version;
	GByteArray * content;
	gboolean deleted;
	gint64 ctime;
	gint64 mtime;
};

struct bean_CONTENTS_HEADERS_s {
	struct bean_header_s header;
	struct fields_CONTENTS_HEADERS_s fields;
};

struct bean_CHUNKS_s {
	struct bean_header_s header;
	struct fields_CHUNKS_s fields;
};

struct bean_PROPERTIES_s {
	struct bean_header_s header;
	struct fields_PROPERTIES_s fields;
};

struct bean_ALIASES_s {
	struct bean_header_s header;
	struct fields_ALIASES_s fields;
};

static struct field_descriptor_s descr_fields_CONTENTS_HEADERS[] =
{
	{ offsetof(struct fields_CONTENTS_HEADERS_s,id), 0, FT_BLOB, 1, 1, "id" },
	{ offsetof(struct fields_CONTENTS_HEADERS_s,hash), 1, FT_BLOB, 0, 0, "hash" },
	{ offsetof(struct fields_CONTENTS_HEADERS_s,size), 2, FT_INT, 0, 1, "size" },
	{ offsetof(struct fields_CONTENTS_HEADERS_s,ctime), 3, FT_INT, 0, 1, "ctime" },
	{ offsetof(struct fields_CONTENTS_HEADERS_s,mtime), 4, FT_INT, 0, 1, "mtime" },
	{ offsetof(struct fields_CONTENTS_HEADERS_s,mime_type), 5, FT_TEXT, 0, 1, "mime_type" },
	{ offsetof(struct fields_CONTENTS_HEADERS_s,chunk_method), 6, FT_TEXT, 0, 1, "chunk_method" },
	{ offsetof(struct fields_CONTENTS_HEADERS_s,policy), 7, FT_TEXT, 0, 0, "policy" },
	{0, 0, FALSE, 0, FALSE, ""}
};

static struct field_descriptor_s descr_fields_CHUNKS[] =
{
	{ offsetof(struct fields_CHUNKS_s,id), 0, FT_TEXT, 1, 1, "id" },
	{ offsetof(struct fields_CHUNKS_s,content), 1, FT_BLOB, 0, 1, "content" },
	{ offsetof(struct fields_CHUNKS_s,position), 2, FT_TEXT, 0, 1, "position" },
	{ offsetof(struct fields_CHUNKS_s,hash), 3, FT_BLOB, 0, 1, "hash" },
	{ offsetof(struct fields_CHUNKS_s,size), 4, FT_INT, 0, 1, "size" },
	{ offsetof(struct fields_CHUNKS_s,ctime), 5, FT_INT, 0, 1, "ctime" },
	{0, 0, FALSE, 0, FALSE, ""}
};

static struct field_descriptor_s descr_fields_PROPERTIES[] =
{
	{ offsetof(struct fields_PROPERTIES_s,alias), 0, FT_TEXT, 1, 1, "alias" },
	{ offsetof(struct fields_PROPERTIES_s,version), 1, FT_INT, 1, 1, "version" },
	{ offsetof(struct fields_PROPERTIES_s,key), 2, FT_TEXT, 1, 1, "key" },
	{ offsetof(struct fields_PROPERTIES_s,value), 3, FT_BLOB, 0, 1, "value" },
	{0, 0, FALSE, 0, FALSE, ""}
};

static struct field_descriptor_s descr_fields_ALIASES[] =
{
	{ offsetof(struct fields_ALIASES_s,alias), 0, FT_TEXT, 1, 1, "alias" },
	{ offsetof(struct fields_ALIASES_s,version), 1, FT_INT, 1, 1, "version" },
	{ offsetof(struct fields_ALIASES_s,content), 2, FT_BLOB, 0, 1, "content" },
	{ offsetof(struct fields_ALIASES_s,deleted), 3, FT_BOOL, 0, 1, "deleted" },
	{ offsetof(struct fields_ALIASES_s,ctime), 4, FT_INT, 0, 1, "ctime" },
	{ offsetof(struct fields_ALIASES_s,mtime), 5, FT_INT, 0, 1, "mtime" },
	{0, 0, FALSE, 0, FALSE, ""}
};

static gchar * descr_fk_names_CONTENTS_HEADERS[] = { "aliases","chunks", NULL };

static gchar * descr_fk_names_CHUNKS[] = { "content", NULL };

static gchar * descr_fk_names_PROPERTIES[] = { "alias", NULL };

static gchar * descr_fk_names_ALIASES[] = { "properties","image", NULL };

static struct fk_descriptor_s descr_fk_CONTENTS_HEADERS[] =
{
	{
		&descr_struct_ALIASES,
		descr_fk_fields_in_FK_ALIASES_CONTENTS_HEADERS_1,
		&descr_struct_CONTENTS_HEADERS,
		descr_fk_fields_out_FK_ALIASES_CONTENTS_HEADERS_1,
		"aliases",
	},
	{
		&descr_struct_CHUNKS,
		descr_fk_fields_in_FK_CHUNKS_CONTENTS_HEADERS_2,
		&descr_struct_CONTENTS_HEADERS,
		descr_fk_fields_out_FK_CHUNKS_CONTENTS_HEADERS_2,
		"chunks",
	},
	{NULL, NULL, NULL, NULL, ""}
};

static struct fk_descriptor_s descr_fk_CHUNKS[] =
{
	{
		&descr_struct_CHUNKS,
		descr_fk_fields_in_FK_CHUNKS_CONTENTS_HEADERS_2,
		&descr_struct_CONTENTS_HEADERS,
		descr_fk_fields_out_FK_CHUNKS_CONTENTS_HEADERS_2,
		"content",
	},
	{NULL, NULL, NULL, NULL, ""}
};

static struct fk_descriptor_s descr_fk_PROPERTIES[] =
{
	{
		&descr_struct_PROPERTIES,
		descr_fk_fields_in_FK_PROPERTIES_ALIASES_0,
		&descr_struct_ALIASES,
		descr_fk_fields_out_FK_PROPERTIES_ALIASES_0,
		"alias",
	},
	{NULL, NULL, NULL, NULL, ""}
};

static struct fk_descriptor_s descr_fk_ALIASES[] =
{
	{
		&descr_struct_PROPERTIES,
		descr_fk_fields_in_FK_PROPERTIES_ALIASES_0,
		&descr_struct_ALIASES,
		descr_fk_fields_out_FK_PROPERTIES_ALIASES_0,
		"properties",
	},
	{
		&descr_struct_ALIASES,
		descr_fk_fields_in_FK_ALIASES_CONTENTS_HEADERS_1,
		&descr_struct_CONTENTS_HEADERS,
		descr_fk_fields_out_FK_ALIASES_CONTENTS_HEADERS_1,
		"image",
	},
	{NULL, NULL, NULL, NULL, ""}
};

const struct bean_descriptor_s descr_struct_CONTENTS_HEADERS =
{
	"contents_headers",
	"contents",
	8,
	"DELETE FROM contents WHERE ",
	27,
	"SELECT id,hash,size,ctime,mtime,mime_type,chunk_method,policy FROM contents",
	75,
	"SELECT COUNT(*) FROM contents",
	29,
	"INSERT OR ABORT INTO contents(id,hash,size,ctime,mtime,mime_type,chunk_method,policy) VALUES (?,?,?,?,?,?,?,?)",
	110,
	"INSERT OR REPLACE INTO contents(id,hash,size,ctime,mtime,mime_type,chunk_method,policy) VALUES (?,?,?,?,?,?,?,?)",
	112,
	"UPDATE contents_headers SET hash=?,size=?,ctime=?,mtime=?,mime_type=?,chunk_method=?,policy=? WHERE id=?",
	104,
	"UPDATE contents_headers SET id=?,hash=?,size=?,ctime=?,mtime=?,mime_type=?,chunk_method=?,policy=? WHERE id=?",
	109,
	offsetof(struct bean_CONTENTS_HEADERS_s,fields),
	sizeof(struct bean_CONTENTS_HEADERS_s),
	8,
	descr_fields_CONTENTS_HEADERS,
	descr_fk_CONTENTS_HEADERS,
	descr_fk_names_CONTENTS_HEADERS,
	1
};

const struct bean_descriptor_s descr_struct_CHUNKS =
{
	"chunks",
	"chunks",
	6,
	"DELETE FROM chunks WHERE ",
	25,
	"SELECT id,content,position,hash,size,ctime FROM chunks",
	54,
	"SELECT COUNT(*) FROM chunks",
	27,
	"INSERT OR ABORT INTO chunks(id,content,position,hash,size,ctime) VALUES (?,?,?,?,?,?)",
	85,
	"INSERT OR REPLACE INTO chunks(id,content,position,hash,size,ctime) VALUES (?,?,?,?,?,?)",
	87,
	"UPDATE chunks SET content=?,position=?,hash=?,size=?,ctime=? WHERE id=?",
	71,
	"UPDATE chunks SET id=?,content=?,position=?,hash=?,size=?,ctime=? WHERE id=?",
	76,
	offsetof(struct bean_CHUNKS_s,fields),
	sizeof(struct bean_CHUNKS_s),
	6,
	descr_fields_CHUNKS,
	descr_fk_CHUNKS,
	descr_fk_names_CHUNKS,
	3
};

const struct bean_descriptor_s descr_struct_PROPERTIES =
{
	"properties",
	"properties",
	10,
	"DELETE FROM properties WHERE ",
	29,
	"SELECT alias,version,key,value FROM properties",
	46,
	"SELECT COUNT(*) FROM properties",
	31,
	"INSERT OR ABORT INTO properties(alias,version,key,value) VALUES (?,?,?,?)",
	73,
	"INSERT OR REPLACE INTO properties(alias,version,key,value) VALUES (?,?,?,?)",
	75,
	"UPDATE properties SET value=? WHERE alias=? AND version=? AND key=?",
	67,
	"UPDATE properties SET alias=?,version=?,key=?,value=? WHERE alias=? AND version=? AND key=?",
	91,
	offsetof(struct bean_PROPERTIES_s,fields),
	sizeof(struct bean_PROPERTIES_s),
	4,
	descr_fields_PROPERTIES,
	descr_fk_PROPERTIES,
	descr_fk_names_PROPERTIES,
	5
};

const struct bean_descriptor_s descr_struct_ALIASES =
{
	"aliases",
	"aliases",
	7,
	"DELETE FROM aliases WHERE ",
	26,
	"SELECT alias,version,content,deleted,ctime,mtime FROM aliases",
	61,
	"SELECT COUNT(*) FROM aliases",
	28,
	"INSERT OR ABORT INTO aliases(alias,version,content,deleted,ctime,mtime) VALUES (?,?,?,?,?,?)",
	92,
	"INSERT OR REPLACE INTO aliases(alias,version,content,deleted,ctime,mtime) VALUES (?,?,?,?,?,?)",
	94,
	"UPDATE aliases SET content=?,deleted=?,ctime=?,mtime=? WHERE alias=? AND version=?",
	82,
	"UPDATE aliases SET alias=?,version=?,content=?,deleted=?,ctime=?,mtime=? WHERE alias=? AND version=?",
	100,
	offsetof(struct bean_ALIASES_s,fields),
	sizeof(struct bean_ALIASES_s),
	6,
	descr_fields_ALIASES,
	descr_fk_ALIASES,
	descr_fk_names_ALIASES,
	0
};


void
CONTENTS_HEADERS_set_id(struct bean_CONTENTS_HEADERS_s *bean, GByteArray * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 0, &v);
}

void
CONTENTS_HEADERS_set2_id(struct bean_CONTENTS_HEADERS_s *bean, const guint8 *v, gsize vlen)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GByteArray *gba = g_byte_array_new_take((guint8*)v, vlen);
	CONTENTS_HEADERS_set_id(bean, gba);
	g_byte_array_free(gba, FALSE);
}

GByteArray *
CONTENTS_HEADERS_get_id(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((GByteArray **)(FIELD(bean,0)));
}

void
CONTENTS_HEADERS_set_hash(struct bean_CONTENTS_HEADERS_s *bean, GByteArray * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 1, &v);
}

void
CONTENTS_HEADERS_set2_hash(struct bean_CONTENTS_HEADERS_s *bean, const guint8 *v, gsize vlen)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GByteArray *gba = g_byte_array_new_take((guint8*)v, vlen);
	CONTENTS_HEADERS_set_hash(bean, gba);
	g_byte_array_free(gba, FALSE);
}

void
CONTENTS_HEADERS_nullify_hash(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	if (_bean_has_field(bean, 1)) {
		HDR(bean)->flags |= BEAN_FLAG_DIRTY;
		_bean_del_field(bean, 1);
	}
}

GByteArray *
CONTENTS_HEADERS_get_hash(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((GByteArray **)(FIELD(bean,1)));
}

void
CONTENTS_HEADERS_set_size(struct bean_CONTENTS_HEADERS_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 2, &v);
}

gint64
CONTENTS_HEADERS_get_size(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((gint64*)(FIELD(bean,2)));
}

void
CONTENTS_HEADERS_set_ctime(struct bean_CONTENTS_HEADERS_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 3, &v);
}

gint64
CONTENTS_HEADERS_get_ctime(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((gint64*)(FIELD(bean,3)));
}

void
CONTENTS_HEADERS_set_mtime(struct bean_CONTENTS_HEADERS_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 4, &v);
}

gint64
CONTENTS_HEADERS_get_mtime(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((gint64*)(FIELD(bean,4)));
}

void
CONTENTS_HEADERS_set_mime_type(struct bean_CONTENTS_HEADERS_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 5, &v);
}

void
CONTENTS_HEADERS_set2_mime_type(struct bean_CONTENTS_HEADERS_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	CONTENTS_HEADERS_set_mime_type(bean, gs);
	g_string_free(gs, TRUE);
}

GString *
CONTENTS_HEADERS_get_mime_type(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((GString **)(FIELD(bean,5)));
}

void
CONTENTS_HEADERS_set_chunk_method(struct bean_CONTENTS_HEADERS_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 6, &v);
}

void
CONTENTS_HEADERS_set2_chunk_method(struct bean_CONTENTS_HEADERS_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	CONTENTS_HEADERS_set_chunk_method(bean, gs);
	g_string_free(gs, TRUE);
}

GString *
CONTENTS_HEADERS_get_chunk_method(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((GString **)(FIELD(bean,6)));
}

void
CONTENTS_HEADERS_set_policy(struct bean_CONTENTS_HEADERS_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	_bean_set_field_value(bean, 7, &v);
}

void
CONTENTS_HEADERS_set2_policy(struct bean_CONTENTS_HEADERS_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	CONTENTS_HEADERS_set_policy(bean, gs);
	g_string_free(gs, TRUE);
}

void
CONTENTS_HEADERS_nullify_policy(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	if (_bean_has_field(bean, 7)) {
		HDR(bean)->flags |= BEAN_FLAG_DIRTY;
		_bean_del_field(bean, 7);
	}
}

GString *
CONTENTS_HEADERS_get_policy(struct bean_CONTENTS_HEADERS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CONTENTS_HEADERS);
	return *((GString **)(FIELD(bean,7)));
}


void
CHUNKS_set_id(struct bean_CHUNKS_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	_bean_set_field_value(bean, 0, &v);
}

void
CHUNKS_set2_id(struct bean_CHUNKS_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	CHUNKS_set_id(bean, gs);
	g_string_free(gs, TRUE);
}

GString *
CHUNKS_get_id(struct bean_CHUNKS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	return *((GString **)(FIELD(bean,0)));
}

void
CHUNKS_set_content(struct bean_CHUNKS_s *bean, GByteArray * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	_bean_set_field_value(bean, 1, &v);
}

void
CHUNKS_set2_content(struct bean_CHUNKS_s *bean, const guint8 *v, gsize vlen)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GByteArray *gba = g_byte_array_new_take((guint8*)v, vlen);
	CHUNKS_set_content(bean, gba);
	g_byte_array_free(gba, FALSE);
}

GByteArray *
CHUNKS_get_content(struct bean_CHUNKS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	return *((GByteArray **)(FIELD(bean,1)));
}

void
CHUNKS_set_position(struct bean_CHUNKS_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	_bean_set_field_value(bean, 2, &v);
}

void
CHUNKS_set2_position(struct bean_CHUNKS_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	CHUNKS_set_position(bean, gs);
	g_string_free(gs, TRUE);
}

GString *
CHUNKS_get_position(struct bean_CHUNKS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	return *((GString **)(FIELD(bean,2)));
}

void
CHUNKS_set_hash(struct bean_CHUNKS_s *bean, GByteArray * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	_bean_set_field_value(bean, 3, &v);
}

void
CHUNKS_set2_hash(struct bean_CHUNKS_s *bean, const guint8 *v, gsize vlen)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GByteArray *gba = g_byte_array_new_take((guint8*)v, vlen);
	CHUNKS_set_hash(bean, gba);
	g_byte_array_free(gba, FALSE);
}

GByteArray *
CHUNKS_get_hash(struct bean_CHUNKS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	return *((GByteArray **)(FIELD(bean,3)));
}

void
CHUNKS_set_size(struct bean_CHUNKS_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	_bean_set_field_value(bean, 4, &v);
}

gint64
CHUNKS_get_size(struct bean_CHUNKS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	return *((gint64*)(FIELD(bean,4)));
}

void
CHUNKS_set_ctime(struct bean_CHUNKS_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	_bean_set_field_value(bean, 5, &v);
}

gint64
CHUNKS_get_ctime(struct bean_CHUNKS_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_CHUNKS);
	return *((gint64*)(FIELD(bean,5)));
}


void
PROPERTIES_set_alias(struct bean_PROPERTIES_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	_bean_set_field_value(bean, 0, &v);
}

void
PROPERTIES_set2_alias(struct bean_PROPERTIES_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	PROPERTIES_set_alias(bean, gs);
	g_string_free(gs, TRUE);
}

GString *
PROPERTIES_get_alias(struct bean_PROPERTIES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	return *((GString **)(FIELD(bean,0)));
}

void
PROPERTIES_set_version(struct bean_PROPERTIES_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	_bean_set_field_value(bean, 1, &v);
}

gint64
PROPERTIES_get_version(struct bean_PROPERTIES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	return *((gint64*)(FIELD(bean,1)));
}

void
PROPERTIES_set_key(struct bean_PROPERTIES_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	_bean_set_field_value(bean, 2, &v);
}

void
PROPERTIES_set2_key(struct bean_PROPERTIES_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	PROPERTIES_set_key(bean, gs);
	g_string_free(gs, TRUE);
}

GString *
PROPERTIES_get_key(struct bean_PROPERTIES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	return *((GString **)(FIELD(bean,2)));
}

void
PROPERTIES_set_value(struct bean_PROPERTIES_s *bean, GByteArray * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	_bean_set_field_value(bean, 3, &v);
}

void
PROPERTIES_set2_value(struct bean_PROPERTIES_s *bean, const guint8 *v, gsize vlen)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GByteArray *gba = g_byte_array_new_take((guint8*)v, vlen);
	PROPERTIES_set_value(bean, gba);
	g_byte_array_free(gba, FALSE);
}

GByteArray *
PROPERTIES_get_value(struct bean_PROPERTIES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_PROPERTIES);
	return *((GByteArray **)(FIELD(bean,3)));
}


void
ALIASES_set_alias(struct bean_ALIASES_s *bean, GString * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	_bean_set_field_value(bean, 0, &v);
}

void
ALIASES_set2_alias(struct bean_ALIASES_s *bean, const gchar *v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GString *gs = g_string_new(v);
	ALIASES_set_alias(bean, gs);
	g_string_free(gs, TRUE);
}

GString *
ALIASES_get_alias(struct bean_ALIASES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	return *((GString **)(FIELD(bean,0)));
}

void
ALIASES_set_version(struct bean_ALIASES_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	_bean_set_field_value(bean, 1, &v);
}

gint64
ALIASES_get_version(struct bean_ALIASES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	return *((gint64*)(FIELD(bean,1)));
}

void
ALIASES_set_content(struct bean_ALIASES_s *bean, GByteArray * v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	_bean_set_field_value(bean, 2, &v);
}

void
ALIASES_set2_content(struct bean_ALIASES_s *bean, const guint8 *v, gsize vlen)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(v != NULL);
	GByteArray *gba = g_byte_array_new_take((guint8*)v, vlen);
	ALIASES_set_content(bean, gba);
	g_byte_array_free(gba, FALSE);
}

GByteArray *
ALIASES_get_content(struct bean_ALIASES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	return *((GByteArray **)(FIELD(bean,2)));
}

void
ALIASES_set_deleted(struct bean_ALIASES_s *bean, gboolean v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	_bean_set_field_value(bean, 3, &v);
}

gboolean
ALIASES_get_deleted(struct bean_ALIASES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	return *((gboolean*)(FIELD(bean,3)));
}

void
ALIASES_set_ctime(struct bean_ALIASES_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	_bean_set_field_value(bean, 4, &v);
}

gint64
ALIASES_get_ctime(struct bean_ALIASES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	return *((gint64*)(FIELD(bean,4)));
}

void
ALIASES_set_mtime(struct bean_ALIASES_s *bean, gint64 v)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	_bean_set_field_value(bean, 5, &v);
}

gint64
ALIASES_get_mtime(struct bean_ALIASES_s *bean)
{
	EXTRA_ASSERT(bean != NULL);
	EXTRA_ASSERT(DESCR(bean) == &descr_struct_ALIASES);
	return *((gint64*)(FIELD(bean,5)));
}

